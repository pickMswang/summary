C++面向对象开发四大特性：封装，抽象，继承，多态
命名空间
所有的标识符都定义在一个叫std的命名空间里面 避免不同模版或库标识符冲突
iostream.h 兼容以前的c++
现在c++不带扩展名
标准库 很多c1-c10
getchar行缓冲只认识回车
gets 获取字符串结尾自动加\0回车不算在内没有溢出检测
puts()用的空间少且速度比printf()快。但只能输出字符串因此函数puts()经常用于代码优化
int printf(const char* control_string,...);
printf()函数返回写入字符的数目，如果出现一个错误，则返回control_string(控制串)变长参数

new实际做的事情三部第一步调用标准库函数operator new申请内存第二部执行类的构造函数进行初始化第三部返回指向新分配的对象的指针
placement new 是重载operator new 的一个标准、全局的版本，它不能够被自定义的版本代替 从已分配好的空间中找一块内存
delete调用析构函数然后调用标准库的operator delete
new/delete 、new []/delete[] 要配对使用多分配了 4 个字节用来保存数组的大小
引用：起别名 声明必须初始化，不是定义一个数据类型本身不占用内存单元 
         不能给数组起别名
引用的应用： 引用作为参数 传递引用给函数与传递指针的效果是一样的，直接对
实参进行操作
                   指针为函数的参数阅读性差 1.*p 2.变量地址作为参数 并且也要给形参分配存储单元
                   引用作为返回值：不能返回局部变量的引用（局部变量会在函数返回时销毁）
                                             不能返回new分配的内存（可能无法释放）

　三、引用总结
　　（1）在引用的使用中，单纯给某个变量取个别名是毫无意义的，引用的目的主要用于在函数参数传递中，解决大块数据或对象的传递效率和空间不如意的问题。
　　（2）用引用传递函数的参数，能保证参数传递中不产生副本，提高传递的效率，且通过const的使用，保证了引用传递的安全性。
　　（3）引用与指针的区别是，指针通过某个指针变量指向一个对象后，对它所指向的变量间接操作。程序中使用指针，程序的可读性差；而引用本身就是目标变量的别名，对引用的操作就是对目标变量的操作。
　　（4）使用引用的时机。流操作符<<和>>、赋值操作符=的返回值、拷贝构造函数的参数、赋值操作符=的参数、其它情况都推荐使用引用。

临时对象时const类型 转化为非const时非法的

类是一种新的数据类型，实现抽象类型的工具，类是对某一类对象的抽象，对象是某一类的实例
对象就是类类型的一个变量，类是抽象的，不占用内存，而对象是具体的占用存储空间

构造函数析构函数由编译器来调用没有返回值与void不同（有返回值就要由程序元显示调用破坏安全性）
拷贝构造函数不能值传递（因为值传递就会重新给形参申请空间调用自身的拷贝死循环）
深复制和浅复制最根本的区别在于是否是真正获取了一个对象的复制实体，而不是引用。
类的非静态成员函数中返回类对象本身的时候，直接使用 return *this
this在成员函数的开始执行前构造，在成员的执行结束后清除。
this指针会因编译器不同而有不同的放置位置。可能是栈，也可能是寄存器，甚至全局变量

类间关系 纵向关系 继承  横向关系 依赖<关联<聚合<组合
依赖 人需要空气 在人的呼吸功能里创建一个空气的对象
关联 朋友平等的关系
组合 部分属于整体

虚函数的作用是为了实现多态机制 虚函数通过虚函数表实现的
虚函数表在编译期就建立了 
虚拟函数表指针在运行期--构造函数被调用时候初始化
子类覆盖了父类的虚函数表

static 面向过程设计
         静态全局变量 特点：
        该变量在全局数据区分配内存
        未经初始化的静态全局变亮被程序自动初始化为0
        静态全局变量在声明它的整个文件可见，其他文件不可见
定义全局变量也可以实现变量在文件中的共享 但定义静态全局变量的好处：
   静态全局变量不能被其他文件所用
  其他文件中可以定义相同名字的变量不会冲突
但有时候我们需要在两次调用之间对变量的值进行保存。通常的想法是定义一个全局变量来实现。但这样一来，变量已经不再属于函数本身了，不再仅受函数的控制，给程序的维护带来不便。
　　静态局部变量正好可以解决这个问题。静态局部变量保存在全局数据区，而不是保存在栈中，每次的值保持到下一次调用，直到下次赋新值。

静态函数：
只能在声名它的文件中可见，不能被其他文件使用
其他文件中可以定义相同名字的函数，不会发生冲突

类中静态数据成员 在没有定义类对象的时候就可以操作了  在类外进行初始化

类中静态成员函数  为类的全部服务而不是为某一个类的对象服务 不具有this指针
?静态成员之间可以相互访问，包括静态成员函数访问静态数据成员和访问静态成员函数； 
?非静态成员函数可以任意地访问静态成员函数和静态数据成员； 
静态成员函数不能访问非静态成员函数和非静态数据成员

const 常类型  const修饰的变量或对象的值是不能被更新的
const常量有数据类型，而宏常量没有数据类型。编译器可以对前者进行类型安全检查，而对后者只进行字符替换，没有类型安全检查，并且在字符替换时可能会产生意料不到的错误
const修饰类的成员函数，则该成员函数不能修改类中任何非const成员函数。
12-const有一个表格
用内联取代宏代码 
C++ 语言支持函数内联，其目的是为了提高函数的执行效率（速度）。 
所有在类的声明中定义的函数将被自动认为是内联函数
如果想将一个全局函数定义为内联函数可用，inline 关键字
当用一个基类的指针删除一个派生类的对象时，派生类的析构函数会被调用。

????当然，并不是要把所有类的析构函数都写成虚函数。因为当类里面有虚函数的时候，编译器会给类添加一个虚函数表，里面来存放虚函数指针，这样就会增加类的存储空间。所以，只有当一个类被用来作为基类的时候，才把析构函数写成虚函数。
