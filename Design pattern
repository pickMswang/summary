设计模式
设计模式是对设计原则的具体化。用江湖话说就是武林秘籍，总结出来的一些固定套路，可以帮助有根基的程序员迅速打通任督二脉，从此做什么都特别快。常用的模式及其场景如下。

1) 单例模式。

单例模式是一种常用的软件设计模式。

在它的核心结构中只包含一个被称为单例类的特殊类。通过单例模式可以保证系统中一个类只有一个实例而且该实例易于外界访问，从而方便对实例个数的控制并节约系统资源。

应用场景：如果希望在系统中某个类的对象只能存在一个，单例模式是最好的解决方案。

2) 工厂模式。

工厂模式主要是为创建对象提供了接口。

应用场景如下：

a、 在编码时不能预见需要创建哪种类的实例。

b、 系统不应依赖于产品类实例如何被创建、组合和表达的细节。

3) 策略模式。

策略模式：定义了算法族，分别封装起来，让它们之间可以互相替换。此模式让算法的变化独立于使用算法的客户。

应用场景如下。

a、 一件事情，有很多方案可以实现。

b、我可以在任何时候，决定采用哪一种实现。

c.、未来可能增加更多的方案。

d、 策略模式让方案的变化不会影响到使用方案的客户。

举例业务场景如下。

系统的操作都要有日志记录，通常会把日志记录在数据库里面，方便后续的管理，但是在记录日志到数据库的时候，可能会发生错误，比如暂时连不上数据库了，那就先记录在文件里面。日志写到数据库与文件中是两种算法，但调用方不关心，只负责写就是。

4) 观察者模式。

观察者模式又被称作发布/订阅模式，定义了对象间一对多依赖，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。

应用场景如下：

a、对一个对象状态的更新，需要其他对象同步更新，而且其他对象的数量动态可变。

b、对象仅需要将自己的更新通知给其他对象而不需要知道其他对象的细节。

5) 迭代器模式。

迭代器模式提供一种方法顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示。

应用场景如下：

当你需要访问一个聚集对象，而且不管这些对象是什么都需要遍 历的时候，就应该考虑用迭代器模式。其实stl容器就是很好的迭代器模式的例子。

6) 模板方法模式。

模板方法模式定义一个操作中的算法的骨架，将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些步骤。

应用场景如下：

对于一些功能，在不同的对象身上展示不同的作用，但是功能的框架是一样的。










整理一下适用场景，便于遇到合适场景时通过使用设计模式更好地去掌握设计模式

设计模式分创建型、行为型、结构型

创建型
策略模式：某一个功能有多种方案可以选择的情景 
单例模式：创建独一无二的，只能有一个实例的对象；一个无状态的类，使用该模式节省资源 
工厂模式：创建新对象，且该对象需要被被封装 
抽象工厂模式：用于创建一组产品（各产品不一定相同） 
建造模式：一个类的各个组成部分的具体实现类或者算法经常面临着变化，但是将他们组合在一起的算法却相对稳定。提供一种封装机制 将稳定的组合算法于易变的各个组成部分隔离开来。 
原型模式：用new创建一个对象需要非常繁琐的数据准备或者权限

行为型
模板模式：架构师用于搭建项目的框架，架构师定好了骨架，程序员继承了骨架的结构之后，负责往里面填空 
命令模式：向某些对象发送请求，但是并不知道请求的接受者是谁，也不知道请求的操作是什么；让程序运行的任何时刻去调用这个方法； 
将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化 
迭代器模式：需要顺序访问一个组合内的多个对象的时候使用。 
观察者模式：异步编程；主题是具有状态的对象，并且可以控制这些状态，观察者使用这些状态，虽然这些状态不属于它们 
状态模式：一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为；个操作中含有庞大的多分支结构，并且这些分支决定于对象的状态 
职责链模式：使多个对象都有机会处理请求，从而避免请求的送发者和接收者之间的耦合关系 
中介者模式：用一个中介对象封装一些列的对象交互 
访问者模式：表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素类的前提下定义作用于这个元素的新操作 
备忘录模式：在不破坏对象的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态

结构型
装饰者模式：增加行为到包装对象上，在不改变对象自身的基础上，在程序运行期间给对象动态的添加职责 
代理模式：为另一个对象提供一个替身或占位符以控制对这个对象的访问 
外观模式：子系统中的一组接口提供一致的界面 
适配器模式：将一类的接口转换成客户希望的另外一个接口；使得原本由于接口不兼容而不能一起工作那些类可以一起工作 
桥梁模式：将抽象部分与它的实现部分相分离，使他们可以独立的变化 
组合模式：将对象组合成树形结构以表示部分整体的关系；使得用户对单个对象和组合对象的使用具有一致性 
享元模式： 
享元模式以共享的方式高效的支持大量的细粒度对象。享元模式能做到共享的关键是区分内蕴状态和外蕴状态。内蕴状态存储在享元内部，不会随环境的改变而有所不同。外蕴状态是随环境的改变而改变的。
