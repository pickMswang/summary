***
STL标准模板库  
STL可分为  
容器(containers)、  
迭代器(iterators)、  
空间配置器(allocator)、  
配接器(adapters)、  
算法(algorithms)、  
仿函数(functors)六个部分  
***
容器  
***

分为   
序列式容器（向量，列表，双端队列）  
适配器容器（栈，队列，优先队列）  
关联式容器（集合，多重集合，映射，多重映射）  
***
序列式容器  
向量(vector) 连续存储的元素<vector>  
列表(list) 由节点组成的双向链表，每个结点包含着一个元素<list>  
双端队列(deque) 连续存储的指向不同元素的指针所组成的数组<deque>  
***
适配器容器  
栈(stack) 后进先出的值的排列 <stack>  
队列(queue) 先进先出的值的排列 <queue>  
优先队列(priority_queue) 元素的次序是由作用于所存储的值对上的某种谓词决定的的一种队列 <queue>  
***
关联式容器  
集合(set) 由节点组成的红黑树，每个节点都包含着一个元素，节点之间以某种作用于元素对的谓词排列，没有两个不同的元素能够拥有相同的次序 <set>  
多重集合(multiset) 允许存在两个次序相等的元素的集合 <set>  
映射(map) 由{键，值}对组成的集合，以某种作用于键对上的谓词排列 <map>  
多重映射(multimap) 允许键对有相等的次序的映射 <map>  
***
迭代器  
在STL中用来将算法和容器联系起来，起着一种黏和剂的作用。  
几乎STL提供的所有算法都是通过迭代器存取元素序列进行工作的，  
每一个容器都定义了其本身所专有的迭代器，用以存取容器中的元素。  
***
***
各容器的实现  
***
set
是用红黑树的平衡二叉索引树的数据结构来实现的，     
插入时，它会自动调节二叉树排列，把元素放到适合的位置，  
确保每个子树根节点的键值大于左子树所有的值、  
小于右子树所有的值，插入重复数据时会忽略。  
set迭代器采用中序遍历，检索效率高于vector、deque、list，  
并且会将元素按照升序的序列遍历。  
set容器中的数值，一经更改，set会根据新值旋转二叉树，以保证平衡，  
构建set就是为了快速检索（python中的set一旦建立就是一个常量，不能改的）。  
set跟vector差不多，
它跟vector的唯一区别就是，
set里面的元素是有序的且唯一的，
只要你往set里添加元素，它就会自动排序，
而且，如果你添加的元素set里面本来就存在，那么这次添加操作就不执行。
***
deque  
和vector一样,采用线性表，与vector唯一不同的是，deque采用的分块的线性存储结构，
每块大小一般为512字节，称为一个deque块，  
所有的deque块使用一个Map块进行管理，  
每个map数据项记录各个deque块的首地址，  
这样以来，deque块在头部和尾部都可已插入和删除元素，  
而不需要移动其它元素。  
使用push_back()方法在尾部插入元素，使用push_front()方法在首部插入元素，使用insert()方法在中间插入元素。一般来说，当考虑容器元素的内存分配策略和操作的性能时，deque相对vectore更有优势。(下面这个图，我感觉Map块就是一个list< map<deque名字，deque地址> >)

*** 
map  
也是使用红黑树，  
他是一个键值对（key：value映射），  
便利时依然默认按照key程序的方式遍历，同set。    
map运用了哈希表地址映射的思想，也就是key-value的思想，来实现的。    
*** 
vector  
C++ STL中的verctor好比是C语言中的数组，    
但是vector又具有数组没有的一些高级功能。与数组相比，  
vector就是一个可以不用再初始化就必须制定大小的边长数组，当然了，它还有许多高级功能。  
虽然vertor对象可以动态增长，  
但是也或有一点副作用：已知的一个限制就是不能再范围for循环中向vector对象添加元素。  
另外一个限制就是任何一种可能改变vector对象容量的操作，不如push_back，都会使该迭代器失效。  

总而言之就是：但凡使用了迭代器的循环体，都不要向迭代器所属的容器添加元素！  
***
list  
list就是链表，在C语言中我们想使用链表都是自己去实现的，  
实现起来倒不难，但是如果有现成的高效的链表可以使用的话，  
我们就不需要重复造轮子了。STL就提供了list容器给我们。  

list是一个双向链表，而单链表对应的容器则是foward_list。  

list即双向链表的优点是插入和删除元素都比较快捷，缺点是不能随机访问元素  
***
***
STL缺点
1.代码膨胀问题  
每一个实例化过的模板类，都会膨胀出一份独立的代码，比如    
std::vector<std::string>, std::vector<int>，编译后会产生两份代码，在VC2008下，每份代码大约是3-4kb，  
这是因为vector比较简单代码少，    
如果是map则会产生30-50kb的代码，因为map里有个复杂的红黑树。  
对于数据处理类的代码里一般会定义很多种不同的结构体，不同的结构体放到不同的容器里，就会实例化出很多个类的代码，  
我见过一个项目里，这样的vector就有数百个。

2. 内存使用效率问题 （以vc++2008为例）  
stl在内存使用效率上是比较低效的，比如std::string，它的sizeof大概是28，  
因为它有一个内置的16字节数组，用来做小字符串优化的，就是说低于16字节的字符串都会至少占用28字节内存，  
如果刚好17字节字符串，则会占用28字节+额外分配的字符串内存，额外分配的内存是一个堆块，又有很多浪费，  
相比用一个char *存储字符串大约多占用了一倍内存。  
还有map<>，每一个map的node都是一块独立分配的内存，如果是 map< int, int>呢，  
那就很悲剧了，为了存一个int要消耗几十个字节，很浪费的。  
如果元素数量有百万级，那么内存占用就很可观了，这种情况下建议自己实现allocator，做内存池。  

3. deep copy问题  
让两个容器的实例做赋值操作，看起来就一条语句，实际上容器里的每个元素都执行了一次赋值操作。  
如果容器里有百万级的数据，那么一个等号就产生了几百万次的构造和析构。  
传递参数的时候一定要用 const 引用，赋值可以用 swap代替。  

4. 隐式类型转换  
比如 有个函数  
void doSomething(const std::string &str);  
调用的时候   
doSomething("hello");  
能编译执行，但是会产生一个临时的匿名的std::string实例，把"hello"复制一遍，然后在调用完成后析构掉。  
如果这个发生在循环体内部有可能影响性能。  

以上这些问题，在小程序里或者数据规模不大的时候，比如容器内元素只有几千这个规模，都不是什么大问题，  
那时开发效率才是重点，但是一旦有大数据stl容器会成为性能瓶颈的  


并发也是一个原因，在需要处理很多并发读写的情况下，提供定制的线程安全的容器和配套算法库，  
可以比使用stl自己套锁来的靠谱。  

