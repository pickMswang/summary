
C++的构造函数和析构函数 
1、构造函数和析构函数为什么没有返回值？
构造函数和析构函数是两个非常特殊的函数：它们没有返回值。这与返回值为void的函数显然不同，后者虽然也不返回任何值，但还可以让它做点别的事情，而构造函数和析构函数则不允许。在程序中创建和消除一个对象的行为非常特殊，就像出生和死亡，而且总是由编译器来调用这些函数以确保它们被执行。如果它们有返回值，要么编译器必须知道如何处理返回值，要么就只能由客户程序员自己来显式的调用构造函数与析构函数，这样一来，安全性就被人破坏了。另外，析构函数不带任何参数，因为析构不需任何选项。
如果允许构造函数有返回值，在某此情况下，会引起歧义。如下两个例子

class C
{
public:
    C(): x(0) {}
    C(int i): x(i) {}

private:
    int x;
};

如果C的构造函数可以有返回值，比如int：int C():x(0) { return 1; } //1表示构造成功，0表示失败
那么下列代码会发生什么事呢？

C c = C();  //此时c.x == 1！！！
很明显，C()调用了C的无参数构造函数。该构造函数返回int值1。恰好C有一个但参数构造函数C(int i)。于是，混乱来了。按照C++的规定，C c = C();是用默认构造函数创建一个临时对象，并用这个临时对象初始化c。此时，c.x的值应该是0。但是，如果C::C()有返回值，并且返回了1（为了表示成功），则C++会用1去初始化c，即调用但参数构造函数C::C(int i)。得到的c.x便会是1。于是，语义产生了歧义。使得C++原本已经非常复杂的语法，进一步混乱不堪。
构造函数的调用之所以不设返回值，是因为构造函数的特殊性决定的。从基本语义角度来讲，构造函数返回的应当是所构造的对象。否则，我们将无法使用临时对象：
void f(int a) {...}  //(1)
void f(const C& a) {...} //(2)
f(C()); //(3)，究竟调用谁？
对于(3)，我们希望调用的是(2)，但如果C::C()有int类型的返回值，那么究竟是调(1)于是，我们的重载体系，乃至整个的语法体系都会崩溃。
这里的核心是表达式的类型。目前，表达式C()的类型是类C。但如果C::C()有返回类型R，那么表达式C()的类型应当是R，而不是C，于是便会引发上述的类型问题。
2、显式调用构造函数和析构函数
#include <iostream>
using namespace std;

class MyClass
{
public:
    MyClass()
    {
        cout << "Constructors" << endl;
    }

    ~MyClass()
    {
        cout << "Destructors" << endl;
    }
};

int main()
{
    MyClass* pMyClass =  new MyClass;
    pMyClass->~MyClass();
    delete pMyClass;

    return 0;
}
结果：
Constructors
Destructors    //这个是显示调用的析构函数
Destructors    //这个是delete调用的析构函数
这有什么用？有时候，在对象的生命周期结束前，想先结束这个对象的时候就会派上用场了。直接调用析构函数并不释放对象所在的内存。
由此想到的： 
new的时候，其实做了三件事，一是：调用::operator new分配所需内存。二是：调用构造函数。三是：返回指向新分配并构造的对象的指针。
delete的时候，做了两件事，一是：调用析构函数，二是：调用::operator delete释放内存。
所以推测构造函数也是可以显式调用的。做个实验：
int main()
{
    MyClass* pMyClass = (MyClass*)malloc(sizeof(MyClass));
    pMyClass->MyClass();
    // …
}
编译pMyClass->MyClass()出错：
error C2273: 'function-style cast' : illegal as right side of '->'operator
它以为MyClass是这个类型。
解决办法有两个：
第一：pMyClass->MyClass::MyClass();
第二：new(pMyClass) MyClass();
第二种用法涉及C++ placement new 的用法。参考：http://www.cnblogs.com/luxiaoxun/archive/2012/08/10/2631812.html
显示调用构造函数有什么用？ 
有时候，你可能由于效率考虑要用到malloc去给类对象分配内存，因为malloc是不调用构造函数的，所以这个时候会派上用场了。
另外下面也是可以的，虽然内置类型没有构造函数。
int* i = (int*)malloc(sizeof(int));
new (i) int();

3、拷贝（复制）构造函数为什么不能用值传递

当你尝试着把拷贝构造函数写成值传递的时候，会发现编译都通不过，错误信息如下：
error: invalid constructor; you probably meant 'S (const S&)' （大致意思是：无效的构造函数，你应该写成。。。）
当编译错误的时候你就开始纠结了，为什么拷贝构造函数一定要使用引用传递呢，我上网查找了许多资料，大家的意思基本上都是说如果用值传递的话可能会产生死循环。编译器可能基于这样的原因不允许出现值传递的拷贝构造函数，也有可能是C++标准是这样规定的。
如果真是产生死循环这个原因的话，应该是这样子的：



class S
{
public:
    S(int x):a(x){ }
    S(const S st) //拷贝构造函数
    {
        a = st.a;
    }
private:
    int a;
};
int main()
{
    S s1(2);
    S s2(s1);
    return 0;
}
当给s2初始化的时候调用了s2的拷贝构造函数，由于是值传递，系统会给形参st重新申请一段空间，然后调用自身的拷贝构造函数把s1的数据成员的值传给st。当调用自身的拷贝构造函数的时候又因为是值传递，所以...
也就是说，只要调用拷贝构造函数，就会重新申请一段空间，只要重新申请一段空间，就会调用拷贝构造函数，这样一直下去就形成了一个死循环。所以拷贝构造函数一定不能是值传递。
4、构造函数/析构函数抛出异常的问题
构造函数抛出异常：
    1.不建议在构造函数中抛出异常；
    2.构造函数抛出异常时，析构函数将不会被执行；
C++仅仅能删除被完全构造的对象（fully contructed objects），只有一个对象的构造函数完全运行完毕，这个对象才能被完全地构造。对象中的每个数据成员应该清理自己，如果构造函数抛出异常，对象的析构函数将不会运行。如果你的对象需要撤销一些已经做了的动作（如分配了内存，打开了一个文件，或者锁定了某个信号量），这些需要被撤销的动作必须被对象内部的一个数据成员记住处理。
析构函数抛出异常：
    在有两种情况下会调用析构函数。第一种是在正常情况下删除一个对象，例如对象超出了作用域或被显式地delete。第二种是异常传递的堆栈辗转开解（stack-unwinding）过程中，由异常处理系统删除一个对象。
在上述两种情况下，调用析构函数时异常可能处于激活状态也可能没有处于激活状态。遗憾的是没有办法在析构函数内部区分出这两种情况。因此在写析构函数时你必须保守地假设有异常被激活，因为如果在一个异常被激活的同时，析构函数也抛出异常，并导致程序控制权转移到析构函数外，C++将调用terminate函数。这个函数的作用正如其名字所表示的：它终止你程序的运行，而且是立即终止，甚至连局部对象都没有被释放。
概括如下：
    1.析构函数不应该抛出异常；
    2.当析构函数中会有一些可能发生异常时，那么就必须要把这种可能发生的异常完全封装在析构函数内部，决不能让它抛出函数之外；
    3.当处理另一个异常过程中，不要从析构函数抛出异常；
    在构造函数和析构函数中防止资源泄漏的好方法就是使用smart point（智能指针），C++ STL提供了类模板auto_ptr，用auto_ptr对象代替原始指针，你将不再为堆对象不能被删除而担心，即使在抛出异常时，对象也能被及时删除。因为auto_ptr的析构函数使用的是单对象形式的delete，而不是delete []，所以auto_ptr不能用于指向对象数组的指针。当复制 auto_ptr 对象或者将它的值赋给其他 auto_ptr 对象的时候，将基础对象的所有权从原来的 auto_ptr 对象转给副本，原来的 auto_ptr 对象重置为未绑定状态。因此，不能将 auto_ptrs 存储在标准库容器类型中。如果要将智能指针作为STL容器的元素，可以使用Boost库里的shared_ptr。



构造函数、析构函数与赋值函数是每个类最基本的函数。它们太普通以致让人容易麻痹大意，其实这些貌似简单的函数就象没有顶盖的下水道那样危险。 
每个类只有一个析构函数和一个赋值函数，但可以有多个构造函数（包含一个拷贝构造函数，其它的称为普通构造函数）。对于任意一个类A，如果不想编写上述函数，C++编译器将自动为A产生四个缺省的函数，如 
A(void); // 缺省的无参数构造函数 
A(const A &a); // 缺省的拷贝构造函数 
~A(void); // 缺省的析构函数 
A & operate =(const A &a); // 缺省的赋值函数 
这不禁让人疑惑，既然能自动生成函数，为什么还要程序员编写？ 
原因如下： 
（1）如果使用“缺省的无参数构造函数”和“缺省的析构函数”，等于放弃了自主“初始化”和“清除”的机会，C++发明人Stroustrup的好心好意白费了。 
（2）“缺省的拷贝构造函数”和“缺省的赋值函数”均采用“位拷贝”而非“值拷贝”的方式来实现，倘若类中含有指针变量，这两个函数注定将出错。 
对于那些没有吃够苦头的C++程序员，如果他说编写构造函数、析构函数与赋值函数很容易，可以不用动脑筋，表明他的认识还比较肤浅，水平有待于提高。 
本章以类String的设计与实现为例，深入阐述被很多教科书忽视了的道理。String的结构如下： 
class String 
{ 
  public: 
String(const char *str = NULL); // 普通构造函数 
String(const String &other); // 拷贝构造函数 
~ String(void); // 析构函数 
String & operate =(const String &other); // 赋值函数 
  private: 
char   *m_data; // 用于保存字符串 
};
