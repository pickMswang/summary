***
1.struct和union的区别
***
1：共用体和结构体都是由多个不同的数据类型成员组成， 但在任何同一时刻， 共用体只存放一个被选中的成员， 而结构体则存放所有的成员变量。  
2：对于共用体的不同成员赋值，将会对其他成员重写， 原来成员的值就不存在了， 而对于结构体的不同成员赋值是互不影响的  
3：内存分配不同，共同体共享同一块内存，而结构体为每一个成员变量分配不同的内存  
***
2.将int func(int A)写成函数指针的形式
***
int (*p)(int)  
***
3.extern“c” 的作用以及为什么要用到它
***
 extern "C"的主要作用就是为了能够正确实现C++代码调用其他C语言代码。  
 加上extern "C"后，会指示编译器这部分代码按C语言的进行编译，而不是C++的。  
 由于C++支持函数重载，因此编译器编译函数的过程中会将函数的参数类型也加到编译后的代码中，而不仅仅是函数名；  
 而C语言并不支持函数重载，因此编译C语言代码的函数时不会带上函数的参数类型，一般之包括函数名。    
     这个功能十分有用处，因为在C++出现以前，很多代码都是C语言写的，而且很底层的库也是C语言写的，  
     为了更好的支持原来的C代码和已经写好的C语言库，需要在C++中尽可能的支持C，而extern "C"就是其中的一个策略。  
这个功能主要用在下面的情况：  
1、C++代码调用C语言代码  
2、在C++的头文件中使用  
3、在多个人协同开发时，可能有的人比较擅长C语言，而有的人擅长C++，这样的情况下也会有用到  
***
4.malloc/free与new/delete的区别
***
a.属性  
　　new/delete是C++关键字，需要编译器支持。malloc/free是库函数，需要头文件支持c。  
b.参数  
　　使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。而malloc则需要显式地指出所需内存的尺寸。  
c.返回类型  
　　new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，  
  故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。  
e. 分配失败  
　　new内存分配失败时，会抛出bac_alloc异常。malloc分配内存失败时返回NULL。  
f.自定义类型  
         new会先调用operator new函数，申请足够的内存（通常底层使用malloc实现）。然后调用类型的构造函数，  
         初始化成员变量，最后返回自定义类型指针。delete先调用析构函数，然后调用operator delete函数释放内存（通常底层使用free实现）。  
         malloc/free是库函数，只能动态的申请和释放内存，无法强制要求其做自定义类型对象构造和析构工作。  
g.重载  
　　C++允许重载new/delete操作符，特别的，布局new的就不需要为对象分配内存，而是指定了一个地址作为内存起始区域，  
  new在这段内存上为对象调用构造函数完成初始化工作，并返回此地址。而malloc不允许重载。  
h.内存区域  
　　new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。  
  自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。  
  而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存  
  自由存储区不等于堆，如上所述，布局new就可以不位于堆中。  
PS:  
 在C++中，内存区分为5个区，分别是堆、栈、自由存储区、全局/静态存储区、常量存储区；  
 在C中，C内存区分为堆、栈、全局/静态存储区、常量存储区；  
 ***
5.实现strcpy  
char * strcpy(char *dst,const char *src)   //[1]  
{  
    assert(dst != NULL && src != NULL);    //[2]  
    char *ret = dst;  //[3]  
    while ((*dst++=*src++)!='\0'); //[4]  
    return ret;  
}  
***
8.建堆的过程  
***
而建堆的核心内容是调整堆，使二叉树满足堆的定义（每个节点的值都不大于其父节点的值）。调堆的过程应该从最后一个非叶子节点开始，   
首先将所有元素按照初始顺序填充到一个完全二叉树中  
从“最后一个非终端节点”开始，调用siftdown方法，调整堆的结构，直到根节点为止  
***
9.构造函数能不能是虚函数，为什么
***
虚函数可谓是C＋＋与其它的面向对象语言最大的区别了。虚函数的存在是为了多态，  
        虚函数的作用主要是为了继承的时候，子类通过继承虚函数的接口，而实现子类自定义的函数接口，我们通过虚函数表的方式寻找到子类对应的接口。从而实现，一个接口多种实现方式的多态功能。  
      那么，有一个问题，构造函数是否能够设置为虚函数？答案是否定的。但是为什么呢？构造函数之所以不能设置成虚函数，主要有以下的几个原因。下面分别阐述一下。  
      1.虚函数的作用是什么？是实现部分或默认的功能，而且该功能可以被子类所修改。如果父类的构造函数设置成虚函数，那么子类的构造函数会直接覆盖掉父类的构造函数。而父类的构造函数就失去了一些初始化的功能。这与子类的构造需要先完成父类的构造的流程相违背了。而这个后果会相当严重。  
      2.虚函数的调用是需要通过“虚函数表”来进行的，而虚函数表也需要在对象实例化之后才能够进行调用。在构造对象的过程中，还没有为“虚函数表”分配内存。所以，这个调用也是违背先实例化后调用的准则。  
      3.虚函数的调用是由父类指针进行完成的，而对象的构造则是由编译器完成的，由于在创建一个对象的过程中，涉及到资源的创建，类型的确定，而这些是无法在运行过程中确定的，需要在编译的过程中就确定下来。而多态是在运行过程中体现出来的，所以是不能够通过虚函数来创建构造函数的，与实例化的次序不同也有关系。  
    那么析构函数为什么可以设计成虚函数呢？由于虚函数是释放对象的时候才执行的，所以一开始也就无法确定析够函数的。而去由于析构的过程中，是先析构子类对象，后析构父类对象。所以，需要通过虚函数来指引子类对象。所以，如果不设置成虚函数的话，析构函数是无法执行子类的析构函数的。  
   所以，基于以上几点原因，构造函数是不能够设置成虚函数的，而析构函数是要设置成虚函数的。而且这个也是面试中会经常提及的考点。  
   ***
10.100亿个数找到重复的一个（给定范围）  
hash（散列表）
