1、命名空间std
　　C++标准中引入命名空间的概念，是为了解决不同模块或者函数库中相同标识符冲突的问题。有了命名空间的概念，标识符就被限制在特定的范围(函数)内，不会引起命名冲突。最典型的例子就是std命名空间，C++标准库中所有标识符都包含在该命名空间中。
　　如果确信在程序中引用某个或者某些程序库不会引起命名冲突（即库中的标识符不会在程序中代表其他函数名称），那么可以通过using操作符来简化对程序库中标识符（通常时函数）的使用，例如：using namespace std;那么就可以不用在标识符在前缀std::来使用C++标准库库中的函数了。
 
　　<iostream>和<iostream.h>是不一样，前者没有后缀，实际上，在你的编译器include文件夹里面可以看到，二者是两个文件，打开文件就会发现，里面的代码是不一样的。后缀为.h的头文件c++标准已经明确提出不支持了，早些的实现将标准库功能定义在全局空间里，声明在带.h后缀的头文件里，c++标准为了和C区别开，也为了正确使用命名空间，规定头文件不使用后缀.h。因此，当使用<iostream.h>时，相当于在c中调用库函数，使用的是全局命名空间，也就是早期的c++实现；当使用<iostream>的时候，该头文件没有定义全局命名空间，必须使用namespacestd；这样才能正确使用cout。、
 
　　C＋＋标准程序库中的所有标识符都被定义于一个名为std的namespace中。由于namespace的概念，使用C＋＋标准程序库的任何标识符时，可以有三种选择：
1、直接指定标识符。例如std::ostream而不是ostream。完整语句如下：
 
　　std::cout << std::hex<< 3.4<< std::endl;
 
2、使用using关键字。
 
　　using std::cout;
　　using std::endl;
 
以上程序可以写成
 
　　cout << std::hex<< 3.4<< endl;
 
3、最方便的就是使用using namespace std;
例如：
　　#include <iostream>
　　#include <sstream>
　　#include <string>
　　using namespace std;
这样命名空间std内定义的所有标识符都有效（曝光）。就好像它们被声明为全局变量一样。那么以上语句可以如下写:
　　cout << hex<< 3.4<< endl;
　　因为标准库非常的庞大，所程序员在选择的类的名称或函数名时就很有可能和标准库中的某个名字相同。所以为了避免这种情况所造成的名字冲突，就把标准库中的一切都被放在名字空间std中。但这又会带来了一个新问题。无数原有的C++代码都依赖于使用了多年的伪标准库中的功能，他们都是在全局空间下的。 所以就有了<iostream.h>和<iostream>等等这样的头文件，一个是为了兼容以前的C++代码，一个是为了支持新的标准。命名空间std封装的是标准程序库的名称，标准程序库为了和以前的头文件区别，一般不加".h"。
