C++内联函数与宏定义的区别  
用内联取代宏： 
1.内联函数在运行时可调试，而宏定义不可以;
2.编译器会对内联函数的参数类型做安全检查或自动类型转换（同普通函数），而宏定义则不会； 
3.内联函数可以访问类的成员变量，宏定义则不能； 
4.在类中声明同时定义的成员函数，自动转化为内联函数。
文章（一） 
内联函数与宏定义
　　在C中，常用预处理语句#define来代替一个函数定义。例如：
　　　　#define MAX(a，b) ((a)>(b)?(a):(b))
　　该语句使得程序中每个出现MAX(a,b)函数调用的地方都被宏定义中后面的表达式((a)>(b)?(a):(b))所替换。
　　宏定义语句的书写格式有过分的讲究， MAX与括号之间不能有空格，所有的参数都要
　　放在括号里。尽管如此，它还是有麻烦：
　　　　int a=1，b=0；
　　　　MAX(a++,b)； //a被增值2次
　　　　MAX(a++,b+10)； //a被增值1次
　　　　MAX(a,"Hello")； //错误地比较int和字符串，没有参数类型检查
　　　　MAX( )函数的求值会由于两个参数值的大小不同而产生不同的副作用。
　　　　MAX(a++,b)的值为2，同时a的值为3；
　　　　MAX(a++,b+10)的值为10，同时a的值为2。
　　如果是普通函数，则MAX(a,"HellO")会受到函数调用的检查，但此处不会因为两个参数类型不同而被编译拒之门外。幸运的是，通过一个内联函数可以得到所有宏的替换效能和 所有可预见的状态以及常规函数的类型检查：
　　　　inline int MAX(int a，int b)
　　　　{
　　　　　return a>b?a:b；
　　　　}
1.内联函数与宏的区别：
      传统的宏定义函数可能会引起一些麻烦。
      ex：
           #define F(x) x+x
           void main(){int i=1;F(i++);}
            这里x将被加两次。
        内联函数被编译器自动的用函数的形势添加进代码，而不会出现这种情况。
        内联函数的使用提高了效率（省去了很多函数调用汇编代码如：call和ret等）。
2.内联函数的使用：
         所有在类的声明中定义的函数将被自动认为是内联函数。
        class A()
       {
             void c();// not a inline function;
            void d(){ print("d() is a inline function.");}
        }
        如果想将一个全局函数定义为内联函数可用，inline 关键字。
        inline a(){print("a() is a inline function.");}
注意：
      在内联函数中如果有复杂操作将不被内联。如：循环和递归调用。
总结：
      将简单短小的函数定义为内联函数将会提高效率。


文章（二） 
8.5.1 用内联取代宏代码 
C++ 语言支持函数内联，其目的是为了提高函数的执行效率（速度）。 
在 C程序中，可以用宏代码提高执行效率。宏代码本身不是函数，但使用起来象函数。预处理器用复制宏代码的方式代替函数调用，省去了参数压栈、生成汇编语言的 CALL调用、返回参数、执行return等过程，从而提高了速度。使用宏代码最大的缺点是容易出错，预处理器在复制宏代码时常常产生意想不到的边际效应。例如 
#define MAX(a, b)       (a) > (b) ? (a) : (b) 
语句  
result = MAX(i, j) + 2 ; 
将被预处理器解释为 
result = (i) > (j) ? (i) : (j) + 2 ; 
由于运算符‘+’比运算符‘:’的优先级高，所以上述语句并不等价于期望的 
result = ( (i) > (j) ? (i) : (j) ) + 2 ; 
如果把宏代码改写为 
#define MAX(a, b)       ( (a) > (b) ? (a) : (b) ) 
则可以解决由优先级引起的错误。但是即使使用修改后的宏代码也不是万无一失的，例如语句 
result = MAX(i++, j); 
将被预处理器解释为 
result = (i++) > (j) ? (i++) : (j); 
对于C++ 而言，使用宏代码还有另一种缺点：无法操作类的私有数据成员。 
让我们看看C++ 的“函数内联”是如何工作的。对于任何内联函数，编译器在符号表里放入函数的声明（包括名字、参数类型、返回值类型）。如果编译器没有发现内联函数存在错误，那么该函数的代码也被放入符号表里。在调用一个内联函数时，编译器首先检查调用是否正确（进行类型安全检查，或者进行自动类型转换，当然对所有的函数都一样）。如果正确，内联函数的代码就会直接替换函数调用，于是省去了函数调用的开销。这个过程与预处理有显著的不同，因为预处理器不能进行类型安全检查，或者进行自动类型转换。假如内联函数是成员函数，对象的地址（this）会被放在合适的地方，这也是预处理器办不到的。 
C++ 语言的函数内联机制既具备宏代码的效率，又增加了安全性，而且可以自由操作类的数据成员。所以在C++ 程序中，应该用内联函数取代所有宏代码，“断言assert”恐怕是唯一的例外。assert是仅在Debug版本起作用的宏，它用于检查“不应该”发生的情况。为了不在程序的Debug版本和Release版本引起差别，assert不应该产生任何副作用。如果assert是函数，由于函数调用会引起内存、代码的变动，那么将导致Debug版本与Release版本存在差异。所以assert不是函数，而是宏。（参见6.5节“使用断言”）
8.5.2 内联函数的编程风格 
关键字inline必须与函数定义体放在一起才能使函数成为内联，仅将inline放在函数声明前面不起任何作用。如下风格的函数Foo不能成为内联函数： 
inline void Foo(int x, int y);  // inline仅与函数声明放在一起 
void Foo(int x, int y) 
{ 
… 
} 
而如下风格的函数Foo则成为内联函数： 
void Foo(int x, int y);  
inline void Foo(int x, int y) // inline与函数定义体放在一起 
{ 
… 
} 
所以说，inline是一种“用于实现的关键字”，而不是一种“用于声明的关键字”。一般地，用户可以阅读函数的声明，但是看不到函数的定义。尽管在大多数教科书中内联函数的声明、定义体前面都加了inline关键字，但我认为inline不应该出现在函数的声明中。这个细节虽然不会影响函数的功能，但是体现了高质量C++/C程序设计风格的一个基本原则：声明与定义不可混为一谈，用户没有必要、也不应该知道函数是否需要内联。 
定义在类声明之中的成员函数将自动地成为内联函数，例如 
class A 
{ 
public: 
void Foo(int x, int y) { … }  // 自动地成为内联函数 
} 
将成员函数的定义体放在类声明之中虽然能带来书写上的方便，但不是一种良好的编程风格，上例应该改成： 
// 头文件 
class A 
{ 
public: 
void Foo(int x, int y)；  
} 
// 定义文件 
inline void A::Foo(int x, int y) 
{ 
… 
} 
(三)慎用内联 

内联能提高函数的执行效率，为什么不把所有的函数都定义成内联函数？ 
如果所有的函数都是内联函数，还用得着“内联”这个关键字吗？ 
内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。以下情况不宜使用内联： 
（1）如果函数体内的代码比较长，使用内联将导致内存消耗代价较高。 
（2）如果函数体内出现循环，那么执行函数体内代码的时间要比函数调用的开销大。 
类的构造函数和析构函数容易让人误解成使用内联更有效。要当心构造函数和析构函数可能会隐藏一些行为，如“偷偷地”执行了基类或成员对象的构造函数和析构函数。所以不要随便地将构造函数和析构函数的定义体放在类声明中。 
一个好的编译器将会根据函数的定义体，自动地取消不值得的内联（这进一步说明了inline不应该出现在函数的声明中）。

 
(四) 一些心得体会 
C++ 语言中的重载、内联、缺省参数、隐式转换等机制展现了很多优点，但是这些优点的背后都隐藏着一些隐患。正如人们的饮食，少食和暴食都不可取，应当恰到好处。我们要辨证地看待C++的新机制，应该恰如其分地使用它们。虽然这会使我们编程时多费一些心思，少了一些痛快，但这才是编程的艺术。 
在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来进行替换。显然，这种做法不会产生转去转回的问题，但是由于在编译时将函数休中的代码被替代到程序中，因此会增加目标程序代码量，进而增加空间开销，而在时间代销上不象函数调用时那么大，可见它是以目标代码的增加为代价来换取时间的节省。
